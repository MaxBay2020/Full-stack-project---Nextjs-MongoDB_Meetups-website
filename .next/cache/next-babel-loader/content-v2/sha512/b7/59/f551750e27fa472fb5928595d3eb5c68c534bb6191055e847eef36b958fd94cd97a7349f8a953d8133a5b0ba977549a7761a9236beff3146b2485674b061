{"ast":null,"code":"import { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Volumes/Seagate Bac/\\u5B66\\u4E60\\u6750\\u6599/\\u524D\\u7AEF/\\u6211\\u7684\\u7EC3\\u4E60/Nextjs/Youtub\\u6559\\u5B66-Nextjs/Next.js Crash Course for Beginners 2021/nextjs-course-main-project/pages/index.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport MeetupList from \"../components/meetups/MeetupList\"; // 我们一般在后端js文件中对数据库进行操作，这个文件是前端js文件\n// 我们之所以能在这个前端js文件中直接操作数据库，是因为next.js会帮助\n// 我们分离这些代码到后端js文件中\n// 因此我们可以在前端js文件中写操作数据库的代码了\n// 这里使用的是原生mongodb，我们也可以使用mongoose来操作数据库\n\nimport { MongoClient } from 'mongodb'; // 这里的props是getStaticProps()方法中返回的props\n\nconst HomePage = props => {\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(MeetupList, {\n      meetups: props.meetups\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 13\n    }, this)\n  }, void 0, false);\n}; // 从数据库取数据\n// 方法一：使用getStaticProps()函数\n// next.js会先找这个名字的函数，这个函数会在这个组件挂载前执行\n// 这个函数一般是异步的，因为我们要在这里方法里准备此组件需要的数据\n// 只有数据回来了，才挂载此组件\n// 这个函数中的代码会执行在后端，因此从数据库获取数据的代码写在这里\n\n\nexport const getStaticProps = async () => {\n  // 从数据库中获取数据的代码\n  const client = await MongoClient.connect('mongodb+srv://wangxiaobei:13ULovEi14962464@cluster0.xpnhi.mongodb.net/meetups?retryWrites=true&w=majority');\n  const db = client.db();\n  const meetupsCollection = db.collection('meetups'); // 查询所有数据\n\n  const meetups = await meetupsCollection.find().toArray();\n  client.close(); // 最后必须返回一个对象\n\n  return {\n    // 里面必须有个叫props的对象，这个就是页面需要的数据了\n    props: {\n      meetups: meetups.map((meetup, index) => _objectSpread(_objectSpread({}, meetup), {}, {\n        _id: index.toString()\n      }))\n    },\n    // revalidate使用来告诉next.js，多久要重新从数据库获取数据的\n    revalidate: 10 // 单位：秒，10秒表示在10秒内请求数据还是旧的数据，超过10秒请求数据next.js就会从数据库读取新数据了\n\n  };\n}; // 从数据库取数据\n// 方法二：使用getStaticProps()函数，这个函数会在每次向数据库请求的时候都会请求最新数据\n// next.js会先找这个名字的函数，这个函数会在这个组件挂载前执行\n// 这个函数一般是异步的，因为我们要在这里方法里准备此组件需要的数据\n// 只有数据回来了，才挂载此组件\n// 这个函数中的代码会执行在后端，因此从数据库获取数据的代码写在这里\n// 这个方法接收context作为参数，context身上可以获取req和res对象，我们就可以获取session了\n// export const  getServerSideProps = async (context)=>{\n//     const req=context.req\n//     const res=context.res\n//     // 从数据库中获取数据的代码\n//\n//     // 最后必须返回一个对象\n//     return {\n//         // 里面必须有个叫props的对象，这个就是页面需要的数据了\n//         props: {\n//             meetups: DUMMY_MEETUPS\n//         }\n//\n//         // 与getStaticProps()方法不同的是：getServerSideProps()方法返回的对象中没有revalidate\n//         // 因为getServerSideProps()方法的实行特点是：每发送一次请求，就从数据库中获取最新数据\n//\n//     }\n// }\n\nexport default HomePage;","map":{"version":3,"sources":["/Volumes/Seagate Bac/学习材料/前端/我的练习/Nextjs/Youtub教学-Nextjs/Next.js Crash Course for Beginners 2021/nextjs-course-main-project/pages/index.js"],"names":["React","MeetupList","MongoClient","HomePage","props","meetups","getStaticProps","client","connect","db","meetupsCollection","collection","find","toArray","close","map","meetup","index","_id","toString","revalidate"],"mappings":";;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,UAAP,MAAuB,kCAAvB,C,CACA;AACA;AACA;AACA;AACA;;AACA,SAAQC,WAAR,QAA0B,SAA1B,C,CAEA;;AACA,MAAMC,QAAQ,GAAIC,KAAD,IAAW;AAExB,sBACI;AAAA,2BACI,QAAC,UAAD;AAAY,MAAA,OAAO,EAAEA,KAAK,CAACC;AAA3B;AAAA;AAAA;AAAA;AAAA;AADJ,mBADJ;AAMH,CARD,C,CAUA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,cAAc,GAAG,YAAU;AACpC;AACA,QAAMC,MAAM,GAAG,MAAML,WAAW,CAACM,OAAZ,CAAoB,2GAApB,CAArB;AACA,QAAMC,EAAE,GAACF,MAAM,CAACE,EAAP,EAAT;AAEA,QAAMC,iBAAiB,GAAGD,EAAE,CAACE,UAAH,CAAc,SAAd,CAA1B,CALoC,CAMpC;;AACA,QAAMN,OAAO,GAAG,MAAMK,iBAAiB,CAACE,IAAlB,GAAyBC,OAAzB,EAAtB;AAEAN,EAAAA,MAAM,CAACO,KAAP,GAToC,CAWpC;;AACA,SAAO;AACH;AACAV,IAAAA,KAAK,EAAE;AACHC,MAAAA,OAAO,EAAEA,OAAO,CAACU,GAAR,CAAY,CAACC,MAAD,EAAQC,KAAR,qCACdD,MADc;AAEjBE,QAAAA,GAAG,EAAED,KAAK,CAACE,QAAN;AAFY,QAAZ;AADN,KAFJ;AAQH;AACAC,IAAAA,UAAU,EAAE,EATT,CASY;;AATZ,GAAP;AAWH,CAvBM,C,CAyBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAejB,QAAf","sourcesContent":["import React from 'react'\nimport MeetupList from \"../components/meetups/MeetupList\"\n// 我们一般在后端js文件中对数据库进行操作，这个文件是前端js文件\n// 我们之所以能在这个前端js文件中直接操作数据库，是因为next.js会帮助\n// 我们分离这些代码到后端js文件中\n// 因此我们可以在前端js文件中写操作数据库的代码了\n// 这里使用的是原生mongodb，我们也可以使用mongoose来操作数据库\nimport {MongoClient} from 'mongodb'\n\n// 这里的props是getStaticProps()方法中返回的props\nconst HomePage = (props) => {\n\n    return (\n        <>\n            <MeetupList meetups={props.meetups} />\n\n        </>\n    );\n};\n\n// 从数据库取数据\n// 方法一：使用getStaticProps()函数\n// next.js会先找这个名字的函数，这个函数会在这个组件挂载前执行\n// 这个函数一般是异步的，因为我们要在这里方法里准备此组件需要的数据\n// 只有数据回来了，才挂载此组件\n// 这个函数中的代码会执行在后端，因此从数据库获取数据的代码写在这里\nexport const getStaticProps = async ()=>{\n    // 从数据库中获取数据的代码\n    const client = await MongoClient.connect('mongodb+srv://wangxiaobei:13ULovEi14962464@cluster0.xpnhi.mongodb.net/meetups?retryWrites=true&w=majority')\n    const db=client.db()\n\n    const meetupsCollection = db.collection('meetups')\n    // 查询所有数据\n    const meetups = await meetupsCollection.find().toArray()\n\n    client.close()\n\n    // 最后必须返回一个对象\n    return {\n        // 里面必须有个叫props的对象，这个就是页面需要的数据了\n        props: {\n            meetups: meetups.map((meetup,index) => ({\n                ...meetup,\n                _id: index.toString()\n            }))\n        },\n        // revalidate使用来告诉next.js，多久要重新从数据库获取数据的\n        revalidate: 10 // 单位：秒，10秒表示在10秒内请求数据还是旧的数据，超过10秒请求数据next.js就会从数据库读取新数据了\n    }\n}\n\n// 从数据库取数据\n// 方法二：使用getStaticProps()函数，这个函数会在每次向数据库请求的时候都会请求最新数据\n// next.js会先找这个名字的函数，这个函数会在这个组件挂载前执行\n// 这个函数一般是异步的，因为我们要在这里方法里准备此组件需要的数据\n// 只有数据回来了，才挂载此组件\n// 这个函数中的代码会执行在后端，因此从数据库获取数据的代码写在这里\n// 这个方法接收context作为参数，context身上可以获取req和res对象，我们就可以获取session了\n// export const  getServerSideProps = async (context)=>{\n//     const req=context.req\n//     const res=context.res\n//     // 从数据库中获取数据的代码\n//\n//     // 最后必须返回一个对象\n//     return {\n//         // 里面必须有个叫props的对象，这个就是页面需要的数据了\n//         props: {\n//             meetups: DUMMY_MEETUPS\n//         }\n//\n//         // 与getStaticProps()方法不同的是：getServerSideProps()方法返回的对象中没有revalidate\n//         // 因为getServerSideProps()方法的实行特点是：每发送一次请求，就从数据库中获取最新数据\n//\n//     }\n// }\n\nexport default HomePage;\n"]},"metadata":{},"sourceType":"module"}